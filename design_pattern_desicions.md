As required, I included the Fallback function as an emergency stop. 

I chose to keep all the user and game information in a struct to help keep all the information organized. Also, by having the user accounts mapped to the struct, it made writing the functions easier. There was no need to require that the sender was actually the right player for most of the functions, since those functions would only allow the sender to access structs that were mapped to their address.  

I also used a commit reveal pattern to store the users' boards. If the boards were stored on the blockchain in plain text before the end of the game, an opponent could look at a user's board and win the game. However, if the user doesn't supply any board information, they could simply cheat and lie about their ship placement. Under the commit reveal pattern, users are required to submit the encrypted board to the blockchain before game play starts. Once the game is finished, both players must load their boards onto the blockchain in plain-text. Thus, the opponent can check and make sure the board matches their guesses. The player then has to prove that the plain-text board matches the encrypted board. If the user doesn't do this within the time limit, they lose the game. 

I focused most of my effort on to the contract-side code. While there are improvements that could be made with the client side code, since that's only in there for testing. While there are some improvements I could have made, such as using the Assert library in the main contract instead of just the test contract, overall I feel fine about it. 
