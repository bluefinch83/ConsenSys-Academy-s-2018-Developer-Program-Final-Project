# ConsenSys-Academy-s-2018-Developer-Program-Final-Project
Final project for ConsenSys Academyâ€™s 2018 Developer Program. 

Note: This project doesn't have a webpage or usable UI. I don't know jQuery or JavaScript, and while I spent the last 2 weeks trying to learn enough to make a UI, I couldn't figure out how to do it. However, the code does run in remix, and the tests do work when using truffle. I just can't get the front-end code to work. 

I use the tag CS a lot in this code. Code and functions tagged with CS are meant to be client side, and would not be part of the final build. Since the game would be unplayable if the locations of player ships were stored on the blockchain and could be seen by anyone, I used a commit reveal design so that players would only have to store an encrypted version of their boards on the blockchain. However, I don't know enough JavaScript to let the user place their ships, store that info, send the contract an encrypted board, or accept a guess from the contract and return the status of that guess using client-side functions. So, I had to stick that code into the contract. However, it's not part of any of the tests and I didn't write it to the same standards as the contract side code. It's mainly there for testing.   

In case you forgot, you can use remix.ethereum.org to run basic solidty code. 

My project should allow users to play battleship with each other. These games are just for fun, and I choose not to allow players to bet on them. The user's information is stored the struct Player, and is mapped to the user adderss. To interact with a game, the user must also know the game number. The two mappings storted in Player are mapped to this number. The game number is a global uint that tracks the total number of games started. It starts at 0. 
To start a game, a user can either choose an opponent to play by using the new2playergame function or start an open game using the newsologame function. They could also join an open game using the joingame function and provided the address of the first player and the game number. 
To place their ships and encode their board, a user will first call the cssetup(uint game#) function. Then, they can place their ships using the placeship(uint game#, uint8 a, uint8 b, uint8 x, uint8 y, uint8 shiptype) function. Note that (a,b), (x,y) are the two end points and that (a,b) must be closer to (0,0) than (x,y) is. Also note that the ship type is an uint and that the Carrier is indexed at 0, Battleship at 1, Cruiser at 2, Sub at 3, and PT-boat at 2. Finally, remember that a battleship board is only 10x10, so a-d can range from 0 to 9. So, if the player wanted to place a carrier from (1,2) to (5,2) in game 7, they would run placeship(7, 1, 2, 5, 2, 0). Once all 5 ships have been placed, the user can encode their board using the encryptboard(uint game#) function. Remember that these last two functions would be client side in the final build, but are part of the contract for testing. The user can then add their code to the blockchain using setboard(bytes32 code, uint game#). Once a second player joins, or is chosen at the start, and both players add their code, the game play can start.
Once the game starts, each player takes turns making guesses. Note that the user who called new2playergame or newsologame is player 1 and goes first. Players can make a guess at point (a,b) using makemove(uint game#, uint8 a, uint8 b). This function should return 3 bools: if the guess was a hit, if a ship was sunk, and if all the opponent's ships have been sunk. If all the opponent's ships haven't been sunk, it's now the other player's turn. If all the ships have sunk, the game ends. 
Once the game ends, both players need to revial their boards before the time expires. To do this, a player would need to store a copy of their board onto the blockchain and call the function checkboard(bytes32 code, uint8[10][10] board,  uint8 game#). This checks to make sure that the code they gave before the game started is the same as encoded their board. Once both players have done this before the time limit, either one can call claimwinbygameplay(uint game) to end the game. This function will emit the winner and store that on the blockchain. If one player fails to show their board before the time limit, the other player can claim victory by calling claimwinbytime(uint game). This function will emit the sender as the victor, no matter who made the game ending move. 

